#!/usr/bin/env node

'use strict';

const execRaw = require('child_process').exec;
const os = require('os');
const path = require('path');
const program = require('commander');
const fs = require('fs-extra');

let TMPDIR = os.tmpdir() || '/tmp';
let TMPPATH;

async function exec (cmd) {
	return new Promise((resolve, reject) => {
		return execRaw(cmd, (err, stdio, stderr) => {
			if (err) return reject(err);
			return resolve(stdio);
		});
	});
}

async function clear () {
	let exists;
	try {
		exists = await fs.exists(TMPPATH);
	} catch (err) {
		console.error(err)
	}

	if (exists) {
		console.log(`Clearing tmp directory ${TMPPATH}`)
		try {
			await exec(`rm -r "${TMPPATH}"`)
		} catch (err) {
			//suppress error
		}
	}

	try {
		await fs.mkdir(TMPPATH)
	} catch (Err) {
		console.error(err);
	}
}

async function frames (video, order) {
	let ext = 'tif';
	let tmpoutput;
	let cmd;

	tmpoutput = path.join(TMPPATH, `export-%05d_${order}.${ext}`);

	cmd = `ffmpeg -i "${video}" -compression_algo raw -pix_fmt rgb24 "${tmpoutput}"`

	console.log(`Exporting ${video} as single frames...`)

	try {
		await exec(cmd)
	} catch (err) {
		console.error('Error exporting video', err)
		return process.exit(3)
	}
	return path.join(TMPPATH, `export_${order}`);
} 

function zeroPad (i, max = 5) {
	let len = (i + '').length;
	let str = i + '';
	for (let x = 0; x < max - len; x++) {
		str = '0' + str;
	}
	return str;
}

async function reorder (pattern, realtime) {
	let frames;
	let old;
	let seqFile;
	let seq;
	console.log('Weaving frames...')
	try {
		frames = await fs.readdir(TMPPATH)
	} catch (err) {
		console.error('Error reading tmp directory', err)
	}

	console.dir(frames)
	frames = frames.filter (file =>{
		if (file.indexOf('.tif') !== -1) return true;
	});
	//other patterns

	try {
		seq = await patternSort(frames, pattern, realtime)
	} catch (err) {
		console.error('Error sorting frames')
	}
	console.dir(seq)
	//
}

function groupAlt (list, pattern, realtime) {
	let groups = [];
	let newList = [];
	let frameCount = 0;
	let oldPath;
	let newName;
	let newPath;
	let ext = path.extname(list[0]);
	
	for (let g of pattern) {
		groups.push([]);
	}
	for (let i = 0; i < list.length; i++) {
		groups[i % pattern.length].push(list[i]);
	}
	for (let x = 0; x < list.length; x++) {
		for (let g of pattern) {
			for (let i = 0; i < g; i++) {

				/*oldPath = path.join(TMPPATH, list[i]);
				newName = `./render_${zeroPad(frameCount)}${ext}`;
				newPath = path.join(TMPPATH, newName);

				console.log(`Renaming ${list[i]} -> ${newName}`);

				try {
					//fs.renameSync(oldPath, newPath)
					newList.push(newName);
				} catch (err) {
					console.error(err);
				}*/

				frameCount++
			}
		}
	}
	return newList
}

async function patternSort (list, pattern, realtime = false) {
	let frameCount = 0;
	let stepCount;
	let step;
	let skipCount;
	let skip;
	let alt;
	let ext = path.extname(list[0]);
	let oldPath;
	let newName;
	let newPath;
	let newList = [];

	for (let el of pattern) {
		if (el !== 1) alt = true;
	}

	if (realtime) {
		skip = false;
		skipCount = pattern.length + 1;
	}
	
	if (!alt) {
		for (let i = 0; i < list.length; i++) {

			if (realtime) {
				skipCount--;
				if (skipCount === 0) {
					skip = !skip;
					skipCount = pattern.length;
				}
			}

			oldPath = path.join(TMPPATH, list[i]);

			if (skip) {
				console.log(`Skipping ${list[i]}`);
				try {
					await fs.unlink(oldPath)
				} catch (err) {
					console.error(err);
				}
				continue;
			}

			newName = `./render_${zeroPad(frameCount)}${ext}`;
			newPath = path.join(TMPPATH, newName);
			console.log(`Renaming ${list[i]} -> ${newName}`);

			try {
				await fs.rename(oldPath, newPath)
				newList.push(newName);
			} catch (err) {
				console.error(err);
			}

			frameCount++;
		}
	} else {
		newList = groupAlt(list, pattern, realtime);
	}

	return newList
}

async function render (output) {
	let exp = path.join(TMPPATH, `render_%05d.tif`);
	let resolution = '1920x1080';
	let h264 = `-vcodec libx264 -g 1 -crf 25 -pix_fmt yuv420p`;
	let prores = `-c:v prores -profile:v 3 -c:a pcm_s16le - g 1`;
	let format = (output.indexOf('.mov') !== -1) ? prores : h264;
	const cmd = `ffmpeg -r 24 -f image2 -s ${resolution} -i ${exp} ${format} -y ${output}`;
	
	console.log(`Exporting video ${output}`);
	console.log(cmd);

	try {
		await exec(cmd);
	} catch (err) {
		console.error(err);
	}
}

async function main (arg) {
	let input = arg.input.split(':');
	let output = arg.output;
	let pattern = [];
	let realtime = false;
	console.time('frameloom');

	if (input.length < 2) {
		console.error('Must provide more than 1 input');
		return process.exit(1);
	}

	if (!output) {
		console.error('Must provide video output path');
		return process.exit(2);
	}

	if (arg.pattern) {
		pattern = arg.pattern.split(':');
		pattern = pattern.map(el =>{
			return parseInt(el);
		})
	} else {
		for (let i = 0; i <input.length; i++) {
			pattern.push(1);
		}
	}

	if (arg.realtime) realtime = true;

	TMPPATH = path.join(TMPDIR, 'frameloom');

	try {
		await clear()
	} catch (err) {
		console.error(err);
		return process.exit(3)
	}

	console.log(`Processing video files ${input.join(', ')} into ${output} with pattern ${pattern.join(':')}`)

	for (let i = 0; i <input.length; i++) {
		try {
			await frames(input[i], i)
		} catch (err) {
			console.error(err);
		}
	}

	try {
		await reorder(pattern, realtime)
	} catch (err) {
		console.error(err)
	}

	try {
		await render(output)
	} catch (err) {
		console.error(err)
	}

	try {
		await clear()
	} catch (err) {
		console.error(err);
		return process.exit(3)
	}

	console.timeEnd('frameloom')
}


 
program
  .version('1.0.0')
  .option('-i, --input [files]', 'Specify input videos with paths seperated by colon')
  .option('-o, --output [file]', 'Specify output path of video')
  .option('-p, --pattern [pattern]', 'Specify a pattern for the flicker 1:1 is standard')
  .option('-r, --realtime', 'Specify if videos should preserve realtime speed')
  .option('-t, --tmp [dir]', 'Specify tmp directory for exporting frames')
  .option('-a, --avconv', 'Specify avconv if preferred to ffmpeg')
  .parse(process.argv);

main(program)